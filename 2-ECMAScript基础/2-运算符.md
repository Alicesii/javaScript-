---
title: 2-运算符
comments: true
date: 2018-04-15 10:04:28
categories: 前端
tags: JavaScript

---

# 运算符

## 1.一元运算符

### 1.1.delete运算符：删除对以前定义的对象属性或方法的引用

```
var str=new String();
str.name="张三"   //"张三"
str.name   //"张三"
delete str.name  //true
str.name   //undefined
```
运算符不能删除未定义的属性和方法

```
var str=new String();

delete str.add() //删除add()方法时将会报错，因为add()方法没有定义。
```
### 1.2.void运算符：对任何值都返回undefined，该运算符通常用于避免输出不应该输出的值。

举例：从HTML的`<a>`元素调用JavaScript函数时，函数不能返回有效值，否则浏览器将清空页面的所有效果只显示函数的结果。

```
<a href="">我是链接</a>
<script>
window.onload=function(){
 var a=document.getElementById("a");
	var test=window.open("about:black");
		  document.write(test);
}
</script>
```
![ ](http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_6.png)

从图中可以看到显示`"[Object window]"`，因为`window.open()`方法反回了对新打开的窗口的应用，然后该对象被转换成要显示的字符串。

解决方法：用void运算符调用`window.open()`函数，这时`window.open()`调用返回undefined，它不是有效的值，所以不会显示在浏览器窗口中。

```
<a href="">我是链接</a>
<script>
window.onload=function(){
  var a=document.getElementById("a");
  var test=void (window.open("about:black"));
	 document.write(test);
}
</script>
```
![ ](http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_7.png)

### 1.3.前增量/前减量运算符

增量/减量运算都发生在计算表达式之前。

### 1.4.后增量/后减量运算符

后缀式运算符是在计算过包含它们的表达式后才进行增量或减量运算的。

```
var num=10

num--  //10

num  //9

--num  //8

num  //8

num--  //8

num  //7
```
总结：前缀式运算符先`++/--`在计算表达式的值，后缀式运算符先计算表达式的值在`++/--`。

### 1.5.一元加法

一元加法本质上对数字无任何影响;

```
var num=10

+num  //10
```
虽然一元加法本质上对数字无任何影响，但可以把字符串转化为数字。

```
var num='10'

typeof num   //"string"

snum=+num  //10

typeof snum  //"number"
```
### 1.6.一元减法

与一元加法运算符相似，一元减法运算符也会把字符串转换成近似的数字，并且还会对值求负。

```
var num='10'

typeof num   //"string"

snum=-num  //-10

typeof snum  //"number"
```
注意：当函数无明确返回值时，返回值也是`undefined`。

## 2.位运算符

### 2.1.关于整数

ECMAScript整数有两种类型：有符号整数和无符号整数。

在ECMAScript中，所有整数字面量默认都是有符号位整数。

有符号位整数使用前31位表示整数的数值，用第32位表示整数的符号，0表示正数，1表示负数。数值的范围从-2147483648~2147483647。

两种方式存储二进制形式的有符号位整数：

* 存储正数：前31位中的每一位都表示2的幂，从第一位开始，表示2的零次方，第二位表示2的一次方，依次类推。

举例：18的二进制只用了前5位，它们是这个数字的有效位，把数字转换成二进制字符串，就只能看到有效位。

```
var num=18

num.toString(2)  //"10010"
```
![ ](http://images.cnblogs.com/cnblogs_com/cliy-10/1255650/o_8.png)

* 存储负数：采用二进制补码的形式

第一步：确定该数字的非负版本的二进制表示(-18->18)

第二步：求得二进制反码，也就是说把0替换为1，把1替换为0;

第三步：在二进制反码上加1

举例：求-18的二进制表示

第一步：确定18的二进制表示：0000 0000 0000 0000 0000 0000 0001 0010

第二步：计算二进制的反码：1111 1111 1111 1111 1111 1111 1110 1101

第三步：反码+1：1111 1111 1111 1111 1111 1111 1110 1110

所以-18的二进制表示为1111 1111 1111 1111 1111 1111 1110 1110

举例：

```
var num=-18

num.toString(2)  //"-10010"
```
大家是不是很奇怪结果输出"-10010"，而非二进制的补码形式1111 1111 1111 1111 1111 1111 1110 1110，这是为了避免开发者访问第31位。

无符号整数的数值范围为0~4294967295。

注意：所有整数字面量都默认存储为有符号位整数，只有用ECMAScript的位运算符才能创建无符号整数。

### 2.2.位运算NOT

位运算NOT由否定号(~)表示,它的处理过程分为三步：

第一步：把运算数转换成32位数字

第二步：把二进制形式转换成它的二进制反码。

第三步：把二进制反码转换成浮点数。

```
var num=18   //0000 0000 0000 0000 0000 0000 0001 0010

var num1=~18 //1111 1111 1111 1111 1111 1111 1110 1101

num1  //-19
```
位运算符实质上是对数字求负，然后减1。

```
var num=18

var num1=-num-1

num1   //-19
```
### 2.3.位运算AND

位运算由和号(&)表示，直接对数字的二进制形式进行运算。

AND的运算规则，只有两个都为1时才为1，其余情况都为0;

举例：

```
var s=25&18 ;

console.log(s);   //16
```
25的二进制形式：0000 0000 0000 0000 0000 0000 0001 1001

18的二进制形式：0000 0000 0000 0000 0000 0000 0001 0010

结果：0000 0000 0000 0000 0000 0001 0000   //16

### 2.4.位运算OR

位运算由竖线(|)表示，直接对数字的二进制形式进行运算。

OR的运算规则，只有两个都为0时才为0，其余情况都为1;

```
var s=25|18 ;

console.log(s);   //16
```
25的二进制形式：0000 0000 0000 0000 0000 0000 0001 1001

18的二进制形式：0000 0000 0000 0000 0000 0000 0001 0010

结果：0000 0000 0000 0000 0000 0001 1011   //27

## 2.5.位运算XOR

位运算由符号(^)表示，直接对数字的二进制形式进行运算。

XOR的运算规则，相同为0，不同为1。

```
var s=25^18 ;

console.log(s);   //16
```
25的二进制形式：0000 0000 0000 0000 0000 0000 0001 1001

18的二进制形式：0000 0000 0000 0000 0000 0000 0001 0010

结果：0000 0000 0000 0000 0000 0000 1011   //11

### 2.6.左移运算

左移运算由两个小于号表示(<<)，它把数字中的所有位数向左移动指定的数量。

```
var num=2   //10

var num1=num<<5 //1000000

console.log(num1)  //64
```
注意：左移操作保留数字的符号位。所以，如果把-2左移5位为-64，而不是64。

```
var num=-2  //-10

var num1=num<<5  //-1000000

console.log(num1)  //-64
```
注意：为了避免开发者访问31位，所以-2显示为-10，而不是1111 1111 1111 1111 1111 1111 1111 1110，-64显示为-1000000而不是1111 1111 1111 1111 1110 0000

### 2.7.有符号右移运算

左移运算由两个大于号表示(>>)，它把数字中的所有位数向右移动指定的数量。

```
var num=64  //1000000

var num1=num>>5 //10

console.log(num1)  //2
```
移动数位后会造成空位，这些空位位于数字的左侧，但是位于符号位之前。

### 2.8.无符号右移运算

无符号左移运算由三个大于号表示(>>>)，它把无符号32位数中的所有位数整体右移。

对于正数，无符号右移运算结果和有符号右移运算结果相同。

```
var num=64  //1000000

var num1=num>>>5 //10

console.log(num1)  //2
```
对于负数，那就呵呵了！！！

```
var num=-64  //1000000

var num1=num>>>5 //111111111111111111111111110

num1  //134217726
```
怎么会出现这种结果呢？

无符号右移运算用0填充所有空位，对于负数由于无符号右移运算的结果是一个32位的正数，所有负数的无符号右移运算得到的总是一个非常大的数字。如何得到这种结果？

```
var num=-64>>>5

num.toString(2)  //"111111111111111111111111110"

num  //134217726
```
## 3.Boolean运算符

Boolean运算符有三种，NOT、AND、OR

### 3.1.逻辑NOT

Boolean运算符NOT由感叹号(~)表示，逻辑NOT运算符的行为如下：

如果运算数是对象，返回false

如果运算符是数字0，返回true

如果运算符是0以外的任何数字，返回false

如果运算符是null,返回true

如果运算符是NaN,返回true

如果运算符是undefined，发生错误

举例：该运算符用于控制循环

```
var bFound=false;
var  i=0;
while(!bFound){
  if(aValues[i]==vSearchValue){
    bFound=true;
  }else{
  i++;
 }
}
```
Boolean变量(bFound)用于记录检索是否成功，找到问题的数据项时，bFound将被设置为true,!bFound将等于false，意味着运行将跳出while循环。

### 3.2.逻辑AND运算符时

逻辑AND运算符用双和号(&&)表示，逻辑AND运算符的行为，只有两个都为true时才为true，其余情况都为false;

如果一个运算符是对象，另一个是Boolean值，返回该对象。

如果两个运算符都是对象，返回第二个对象

如果某个运算符是null，返回null

如果某个运算符是NaN，返回NaN

如果运算符是undefined，发生错误

如果第一个运算数决定了结果，就不再计算第二个运算数，对于逻辑AND运算来说，如果第一个运算数是false,那么无论第二个运算数的值是什么，结果都不可能等于true。

```
var a=true

var s=a&&b  //报错(b没有被定义)

console.log(s)//这句将不会被执行
```

报错的原因：a的值true，逻辑AND运算将继续计算变量b的值，由于变量b是未定义的，不能用于逻辑AND运算，这样做就会引发错误。

```
var a=false

var s=a&&b

console.log(s) //false
```
第一个运算数是false,即使第二个变量的值是未定义的，结果都是false，这一点很重要。

### 3.3.OR

位运算由双竖线(||)表示，逻辑OR运算符的行为，只有两个都为false时才为false，其余情况都为true;

如果一个运算符是对象，另一个是Boolean值，返回该对象。

如果两个运算符都是对象，返回第一个对象

如果某个运算符是null，返回null

如果某个运算符是NaN，返回NaN

如果运算符是undefined，发生错误

如果第一个运算数决定了结果，就不再计算第二个运算数，对于逻辑OR运算来说，如果第一个运算数是true,那么无论第二个运算数的值是什么，结果都不可能等于false。

```
var a=true

var s=a||b

console.log(s) //true
```
第一个运算数是true,即使第二个变量的值是未定义的，结果都是true。

```
var a=false

var s=a||b  //报错(b没有被定义)

console.log(s)//这句将不会被执行
```
报错的原因：a的值为false，逻辑OR运算将继续计算变量b的值，由于变量b是未定义的，不能用于逻辑OR运算，这样做就会引发错误。

## 4.乘性运算符

### 4.1.乘法运算符

乘法运算符由星号`(*)`表示，用于表示两个数相乘。

规则：

如果运算数都是数字，执行常规的乘法运算，即两个整数或两个负数相乘结果为正数，两个运算数符号不同，结果为负数。如果运算结果太大生成的结果是Infinity，如果运算结果太小生成的结果是-Infinity。

如果某个运算数是NaN，结果为NaN。

Infinity乘以0,结果为NaN

Infinity乘以0以外的任何数字，结果为Infinity或-Infinity(由第二个运算数的符号决定)

Infinity乘以Infinity，结果为Infinity。

### 4.2.除法运算符

除法运算符由斜线`(/)`表示，用第二个运算数除第一个运算数。

规则：

如果运算数都是数字，执行常规的除法运算，即两个整数或两个负数除法结果为正数，两个运算数符号不同，结果为负数。如果运算结果太大生成的结果是Infinity，如果运算结果太小生成的结果是-Infinity。

如果某个运算数是NaN，结果为NaN。

Infinity被Infinity除,结果为NaN

Infinity被任何数除，结果为Infinity。

0除以一个非无穷大的数字，结果为NaN。

Infinity被0以外的任何数字除，结果为Infinity或-Infinity(由第二个运算数的符号决定)

### 4.3.取模运算符

取模运算符由斜线`(%)`表示。

规则：

如果运算数都是数字，执行常规的除法运算，返回除法运算得到的余数。

如果被除数是Infinity，或者除数是0，结果为NaN。

Infinity被Infinity除,结果为NaN

如果除数是无穷大的数，结果为被除数。

如果被除数为0，结果为0。

## 5.加性运算符

### 5.1.加法运算符

加法运算符由符号`(+)`表示。

规则：

某个运算数是NaN,结果为NaN

Infinity加Infinity，结果为Infinity。

-Infinity加-Infinity，结果为-Infinity。

Infinity加-Infinity，结果为NaN。

+0加+0，结果为+0。

-0加+0，结果为+0。

-0加-0，结果为-0。

如果某个运算符是字符串，将采用以下规则：

如果两个运算数都是字符串，把第二个字符串连接到第一个字符串上。

如果只有一个运算符是字符串，把另一个运算符转换成字符串，结果是两个字符串连接成的字符串。

```
var str=5+5

console.log(str); //10

var str=5+'5'

console.log(str)  //"55"
```
### 5.2.减法运算符

减法运算符由符号`(-)`表示。

规则：

某个运算数是NaN,结果为NaN

Infinity减Infinity，结果为NaN。

-Infinity减-Infinity，结果为NaN。

Infinity减-Infinity，结果为Infinity。

-Infinity减Infinity，结果为-Infinity。

+0减+0，结果为+0。

-0减-0，结果为-0。

某个运算符不是数字，结果为NaN.

## 6.关系运算符

关系运算符小于(<)、大于(>)、小于等于(<=)和大于等于(>=)执行的是两个数的比较运算，每个关系运算符都返回一个Boolean值。

举例：

```
var s="Bdedee"<"aldee"

console.log(s); //true
```
字母"Bdedee"小于"aldee"，原因是字母B的ASCII是66，字母a的ASCII是97。如果要强制性得到按照真正的字母顺序比较的结果，必须把这两个运算符转换成相同的大小写形式(全大写或者全小写)，然后在进行比较，才可以得到比较正常的数据。

```
var s="Bdedee".toLowerCase()<"aldee".toLowerCase()

console.log(s); //false
```
当我们比较两个字符串形式的数字时，会发生什么呢？

```
var s="51"<"6"

console.log(s)  //true
```
原因：两个运算符都是字符串，所以比较的是它们的ASCII值。(字符串"51"的ASCII值为53，字符串"6"的ASCII值为54)

当我们比较的一个为字符串，一个为数字时，又会发生什么呢？

```
var s="51"<6

console.log(s) //false
```
这就有趣了，字符串"51"被转换成了数字51,然后和数字6进行比较，肯定是数字51比较大了。

我们再来看一种令人不可思议的情况

```
var s="a"<6

console.log(s) //false
```
为什么会输出false呢？我真是不能理解了，字母"a"不能转换成有意义的数字，如果对它调用parseInt()方法，返回值为NaN，根据规则，任何包含NaN的关系运算都要返回false。

## 7.等性运算符

判断两个变量是否相等，在处理原始值时，这种运算相当简单，但涉及到对象，任务就有些复杂。

### 7.1.等号和非等号

等号由双等号(==)表示，当且仅当两个运算数相等时，它返回true。

非等号由感叹号加等号`(!=)`，当且仅当两个运算数不相等时，它返回true。

规则：

如果一个运算数是Boolean值，在检查相等性之前，把它转换成数字值，false转换成0，true抓换成1.

如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。

如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串(调用toString()方法)

如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字(调用valueOf()方法)

注意：

* 值null和undefined相等

* 在检查相等性时，不能把null和undefined转换成其他值

* 如果两个运算符都是对象，那么比较的是它们的引用值，如果两个运算数指向同一个对象，那么返回true，否则返回false。

* 如果某个运算数是NaN,等号将返回false,非等号将返回true。(NAN它与自身不相等)

NaN==NaN   //false

我们可以使用`isNaN()`函数来判断一个数的数据类型是不是非数。

举例：

```
var obj={age:18}

obj.age==18  //true

obj.name="zhangsan"

obj.name=="zhangsan" //true

null==undefined  //true

"NaN"==NaN  //false

0==NaN  //false

NaN==NaN  //false

false==0  //true

true==1  //true

NaN!=NaN  //true

true==2  //false(true==1!=2)
```
### 7.2.全等号和非全等号

全等号和非全等号运算符所做的与等号和非等号相同，只是它们在类型检查相等性前，不执行类型转换。

全等号由三个等号(===)表示，只有在无需类型转换运算数就相等的情况下，才返回true。

非全等号由三个等号(!==)表示，只有在无需类型转换运算数不相等的情况下，才返回true。

举例：

```
var s= "5"===5

console.log(s)  //false

var s= "5"==5

console.log(s)  //true

var s= "5"!==5

console.log(s) //true

var s= "5"!=5

console.log(s)  //false
```
### 7.3.总结：

全等("===")

1、如果类型不同，就[不相等]

2、如果两个都是数值，并且是同一个值，那么[相等]；(!例外)的是，如果其中至少一个是NaN，那么[不相等]。

3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。

4、如果两个值都是true，或者都是false，那么[相等]。

5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。

6、如果两个值都是null，或者都是undefined，那么[相等]。

等号("==")

1、如果两个值类型相同，进行 === 比较。

2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：

  a、如果一个是null、一个是undefined，那么[相等]。

  b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。

  c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。

  d、如果一个是对象，另一个是数值或字符串，把引用类型转换成原始类型类型的值再比较，利用它的toString()或者valueOf()方法。

  e、任何其他组合，都[不相等]。

## 8.条件运算符

`variable=boolean_expression?true_value:false_value;`

该表达式主要是根据boolean_expression的计算结果有条件的为变量赋值。如果boolean_expression为true,就把true_value赋给变量，如果它为false，就把false_value赋给变量。

## 9.赋值运算符

简单的赋值运算由等号(=)实现，只是把等号右边的值赋给等号左边的变量。

复合赋值运算是由乘性运算符、加性运算符或者移位运算符加等号(=)实现的。

每种主要的算术运算以及其他几个运算都要符合赋值运算符：

乘法/赋值：(* =)

除法/赋值：(/ =)

取模/赋值：(% =)

加法/赋值：(+ =)

减法/赋值：(- =)

左移/赋值：(<< =)

有符号右移/赋值：(>> =)

无符号右移/赋值：(>>> =)

## 10.逗号运算符

用逗号运算符可以再一条语句中执行多个运算。

`var a=1,b=2,c=3;`
